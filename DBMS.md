# Экзаменационные билеты

## База данных. Классификация БД. Реляционная модель данных.

### База данных (БД) 
Организованное собрание данных, хранящихся в компьютерной системе. Она позволяет пользователям создавать, изменять, удалять и извлекать данные. Базы данных используются для различных целей, включая хранение информации, анализ данных, управление транзакциями и многое другое.

### Классификация баз данных
Базы данных можно классифицировать по различным критериям, включая структуру данных, модель данных, тип данных и область применения. Вот основные типы баз данных:

- *По структуре данных*: 
  - Реляционные базы данных (RDBMS): Данные организованы в таблицы, где каждая строка представляет запись, а столбцы — атрибуты этой записи. Примеры: MySQL, PostgreSQL, Oracle Database.
  - Нереляционные базы данных (NoSQL): Данные могут быть организованы в различных форматах, таких как ключ-значение, документоориентированные, графовые и столбцовые. Примеры: MongoDB, Cassandra, Redis.
- *По модели данных*: 
  - Реляционная модель данных: Использует таблицы для хранения данных, где каждая строка представляет запись, а столбцы — атрибуты этой записи.
  - Объектно-ориентированная модель данных: Данные представлены в виде объектов, которые могут содержать данные и методы для работы с этими данными.
  - Графовая модель данных: Данные представлены в виде узлов и ребер, которые связывают узлы между собой.
- *По типу данных*:
  - Структурированные базы данных: Данные имеют фиксированную структуру и могут быть легко организованы в таблицы.
  - Полуструктурированные базы данных: Данные могут иметь частично структурированную форму, например, XML или JSON.
  - Неструктурированные базы данных: Данные не имеют фиксированной структуры и могут быть представлены в различных форматах, таких как текст, изображения, видео.
- По области применения:
  - Операционные базы данных (OLTP): Используются для обработки транзакций в реальном времени, например, в банковских системах.
  - Аналитические базы данных (OLAP): Используются для анализа больших объемов данных, например, в бизнес-аналитике.

### Реляционная модель данных
Модель, в которой данные организованы в таблицы. Каждая таблица состоит из строк и столбцов. Строки представляют записи, а столбцы — атрибуты этих записей. В этой модели данные хранятся в таблицах, которые связаны друг с другом через ключи.

#### Основные концепции реляционной модели данных:

- Таблица: Коллекция данных, организованная в строки и столбцы.
- Строка: Запись в таблице, представляющая экземпляр сущности.
- Столбец: Атрибут записи, представляющий определенный тип данных.
- Ключ: Уникальный идентификатор записи в таблице.
- Связь: Связь между двумя таблицами, основанная на ключах.

Реляционная модель данных обеспечивает гибкость и эффективность при работе с данными, позволяя легко изменять структуру данных и обеспечивая целостность данных через механизмы ограничений и транзакций.

## Язык SQL. Основные типы данных. Операторы DDL и DML.

### Язык SQL
Стандартный язык для управления и манипулирования данными в реляционных базах данных. SQL позволяет создавать, изменять и удалять структуры баз данных, а также вставлять, обновлять, удалять и выбирать данные. SQL используется для взаимодействия с базами данных, такими как MySQL, PostgreSQL, Oracle Database и многими другими.

### Основные типы данных в SQL
В SQL существует несколько основных типов данных, которые используются для определения типа данных столбцов в таблицах. Вот некоторые из них:

- Числовые типы:
  - INTEGER: Целые числа.
  - SMALLINT: Маленькие целые числа.
  - BIGINT: Большие целые числа.
  - DECIMAL: Числа с фиксированной точностью.
  - FLOAT: Числа с плавающей точкой.
  - REAL: Числа с плавающей точкой с ограниченной точностью.

- Строковые типы:
  - CHAR: Фиксированная длина строка.
  - VARCHAR: Переменная длина строка.
  - TEXT: Длинная строка.

- Дата и время:
  - DATE: Дата.
  - TIME: Время.
  - DATETIME: Дата и время.
  - TIMESTAMP: Отметка времени.

- Булевы типы:
  - BOOLEAN: Логический тип, который может принимать значения TRUE или FALSE.

- Бинарные типы:
  - BINARY: Двоичные данные.
  - VARBINARY: Переменная длина двоичных данных.
  - BLOB: Большой объект двоичных данных.

### Операторы DDL и DML
В SQL существуют два основных типа операторов: DDL (Data Definition Language) и DML (Data Manipulation Language).

#### DDL (Data Definition Language)
DDL используется для определения и управления структурой базы данных. \
Основные операторы DDL:
- CREATE: Создает новую базу данных, таблицу, индекс, представление или другие объекты. 
- ALTER: Изменяет структуру существующих объектов, например, добавляет или удаляет столбцы в таблице.
- DROP: Удаляет существующие объекты, такие как базы данных, таблицы или индексы.
- TRUNCATE: Удаляет все записи из таблицы, но оставляет структуру таблицы нетронутой.

#### DML (Data Manipulation Language)
DML используется для вставки, обновления, удаления и выборки данных в базе данных. \
Основные операторы DML:
- SELECT: Выбирает данные из одной или нескольких таблиц.
- INSERT: Вставляет новые записи в таблицу.
- UPDATE: Обновляет существующие записи в таблице.
- DELETE: Удаляет записи из таблицы.

SQL является мощным инструментом для работы с реляционными базами данных, позволяя разработчикам и администраторам баз данных эффективно управлять и манипулировать данными.

## Реляционная алгебра. Основные понятия и операции.

### Реляционная алгебра
Формальная система для описания операций над реляционными базами данных. Она используется для преобразования запросов SQL в более эффективные запросы, а также для анализа и оптимизации запросов. Реляционная алгебра состоит из набора операций, которые можно применять к реляционным таблицам для получения новых таблиц.

### Основные понятия
- Реляция: В контексте реляционной алгебры, реляция — это таблица, состоящая из строк и столбцов. Каждая строка представляет запись, а столбцы — атрибуты этой записи.
- Атрибут: Атрибут — это столбец в таблице, представляющий определенный тип данных.
- Ключ: Ключ — это атрибут или набор атрибутов, который уникально идентифицирует запись в таблице.

### Основные операции
Реляционная алгебра включает в себя следующие основные операции:
- Проекция (π): Выборка определенных атрибутов из реляции. Например, если у нас есть реляция Students с атрибутами Name, Age, и Grade, проекция на атрибут Name будет выглядеть так: π Name (Students).
- Объединение (⋃): Соединение двух реляций по одному или нескольким общим атрибутам. Объединение может быть внутренним (только общие записи) или внешним (все записи из обеих реляций).
- Пересечение (⋂): Выборка записей, которые присутствуют в обеих реляциях.
- Разность (−): Выборка записей, которые присутствуют в первой реляции, но отсутствуют во второй.
- Произведение (×): Соединение всех записей из первой реляции с записями из второй реляции, где каждая запись из первой реляции соединяется с каждой записью из второй реляции.
- Селекция (σ): Выборка записей из реляции, которые удовлетворяют определенному условию. Например, σ Age > 18 (Students) выберет всех студентов старше 18 лет.
- Разделение (÷): Операция, которая разделяет реляцию на две части по определенному атрибуту.
- Объединение (∪): Соединение всех записей из двух реляций.
- Интерсекция (∩): Выборка записей, которые присутствуют в обеих реляциях.
- Диаметр (⋈): Операция, которая соединяет две реляции по одному или нескольким общим атрибутам, но возвращает только уникальные пары значений.

Реляционная алгебра позволяет формализовать и анализировать запросы к базам данных, обеспечивая более глубокое понимание того, как запросы выполняются и как они могут быть оптимизированы.

## Типы связей в SQL. Функциональная зависимость. Нормальные формы с 1 по 4.

### Типы связей в SQL
В SQL существуют три основных типа связей между таблицами:

- Один к одному (1:1): Каждая запись в первой таблице соответствует одной записи в второй таблице, и наоборот. Примером может служить связь между таблицей Employees и таблицей Passports, где каждому сотруднику соответствует один паспорт.
- Один ко многим (1:N): Одна запись в первой таблице может соответствовать нескольким записям во второй таблице, но каждая запись во второй таблице соответствует только одной записи в первой таблице. Примером может служить связь между таблицей Authors и таблицей Books, где один автор может написать несколько книг.
- Многие ко многим (N:M): Записи в первой таблице могут соответствовать нескольким записям во второй таблице, и наоборот. Для реализации такой связи обычно используется дополнительная таблица, которая содержит внешние ключи из обеих связанных таблиц. Примером может служить связь между таблицей Students и таблицей Courses, где каждый студент может записаться на несколько курсов, и каждый курс может быть выбран несколькими студентами.

### Функциональная зависимость
Отношение между атрибутами в таблице, где значение одного атрибута определяет значение другого атрибута. Например, в таблице Students атрибут StudentID функционально зависит от атрибута Name, так как каждому студенту соответствует уникальный идентификатор.

### Нормальные формы
Набор правил, которые помогают минимизировать дублирование данных и улучшить структуру базы данных. Существует несколько нормальных форм, каждая из которых представляет собой набор условий, которые должны быть выполнены для достижения определенного уровня структурирования данных.

- Первая нормальная форма (1NF): В таблице не должно быть дублирующихся групп атрибутов. Каждый столбец должен содержать только атомарные (неделимые) значения, и каждая запись должна быть уникальной.
- Вторая нормальная форма (2NF): Таблица должна быть в 1NF, и все не ключевые атрибуты должны быть полностью функционально зависимы от первичного ключа. Это означает, что в таблице не должно быть частичных зависимостей.
- Третья нормальная форма (3NF): Таблица должна быть в 2NF, и все не ключевые атрибуты должны быть напрямую зависимы от первичного ключа, а не от других не ключевых атрибутов. Это означает, что в таблице не должно быть транзитивных зависимостей.
- Четвертая нормальная форма (4NF): Таблица должна быть в 3NF, и все многозначные атрибуты должны быть разделены на отдельные таблицы, чтобы избежать дублирования данных. Это означает, что в таблице не должно быть зависимостей между многозначными атрибутами.
Переход от одной нормальной формы к другой помогает улучшить структуру базы данных, уменьшить дублирование данных и упростить процесс обновления данных.

## Зависимость соединения. Нормальные формы с 5 по 6.

### Зависимость соединения
Отношение между атрибутами в таблице, где значение одного атрибута определяет значение другого атрибута, но только в контексте определенного набора значений другого атрибута. Это более строгий тип зависимости, чем простая функциональная зависимость, и он часто встречается в реальных базах данных.

Примером зависимости соединения может служить таблица Orders, где атрибут OrderID определяет атрибут ProductID, но только в контексте определенного CustomerID. То есть, для каждого клиента (CustomerID) может быть уникальный набор продуктов (ProductID), но для разных клиентов один и тот же ProductID может соответствовать разным OrderID.

### Нормальные формы с 5 по 6
Нормальные формы, начиная с 5NF, были введены для решения более сложных проблем, связанных с дублированием данных и зависимостями в базах данных.

- Пятая нормальная форма (5NF): Таблица должна быть в 4NF, и все атрибуты должны быть зависимы только от первичного ключа. Это означает, что в таблице не должно быть зависимостей между атрибутами, которые не являются частью первичного ключа.
- Шестая нормальная форма (6NF): Таблица должна быть в 5NF, и все атрибуты должны быть зависимы только от первичного ключа и от атрибутов, которые являются частью первичного ключа. Это означает, что в таблице не должно быть зависимостей между атрибутами, которые не являются частью первичного ключа или не являются частью атрибутов, которые уже зависят от первичного ключа.
Переход от 4NF к 5NF и далее помогает улучшить структуру базы данных, уменьшить дублирование данных и упростить процесс обновления данных. Однако стоит отметить, что применение нормальных форм с 5 по 6 может быть излишним в большинстве практических ситуаций, поскольку они предназначены для решения очень специфических проблем, которые встречаются редко. В большинстве случаев достижение третьей нормальной формы (3NF) уже обеспечивает достаточно хорошую структуру данных для большинства приложений.

## Структура оператора SQL Select. Индексы. MySQL оператор EXPLAIN.

### Структура оператора SQL Select
Оператор SELECT в SQL используется для извлечения данных из базы данных. Он может быть использован с различными ключевыми словами и функциями для управления выборкой данных. Основная структура оператора SELECT выглядит следующим образом:
```
SELECT [DISTINCT] column1, column2, ...
FROM table_name
[WHERE condition]
[GROUP BY column1, column2, ...]
[HAVING condition]
[ORDER BY column1, column2, ... ASC|DESC]
[LIMIT number]
[OFFSET number]
```

- SELECT: Указывает, какие столбцы из таблицы нужно извлечь.
- FROM: Указывает таблицу, из которой нужно извлечь данные.
- WHERE: Указывает условие, которому должны соответствовать извлекаемые записи.
- GROUP BY: Группирует результаты по одному или нескольким столбцам.
- HAVING: Указывает условие для групп, созданных с помощью GROUP BY.
- ORDER BY: Сортирует результаты по одному или нескольким столбцам.
- LIMIT: Ограничивает количество возвращаемых записей.
- OFFSET: Пропускает указанное количество записей перед возвращением результатов.

### Индексы
Индексы в SQL используются для ускорения операций поиска и сортировки данных. Они создаются на столбцах таблицы и позволяют базе данных быстрее находить данные, соответствующие определенным условиям. Индексы могут быть уникальными (не допускают дубликатов) или неуникальными.

### MySQL оператор EXPLAIN
Оператор EXPLAIN в MySQL используется для получения информации о том, как MySQL планирует выполнить запрос. Это может быть полезно для оптимизации запросов, поскольку позволяет понять, какие индексы используются, какие таблицы сканируются и в каком порядке, а также оценить эффективность запроса.

Пример использования EXPLAIN:
```
EXPLAIN SELECT * FROM table_name WHERE column_name = 'value';
```

Результат выполнения EXPLAIN включает в себя различные детали, такие как:

- id: Идентификатор запроса.
- select_type: Тип запроса (например, SIMPLE, PRIMARY, SUBQUERY).
- table: Таблица, используемая в запросе.
- type: Тип доступа к таблице (например, ALL, index, range).
- possible_keys: Ключи, которые могут быть использованы для выполнения запроса.
- key: Фактически использованный ключ.
- key_len: Длина ключа.
- ref: Столбцы или константы, используемые для поиска.
- rows: Приблизительное количество строк, которые нужно проверить.
- Extra: Дополнительная информация о выполнении запроса.
Использование EXPLAIN помогает разработчикам и администраторам баз данных понять, как MySQL обрабатывает запросы, и оптимизировать их для улучшения производительности.

## Транзакции. Уровни изоляции транзакций в MySQL. Блокировка и разблокировка таблиц.

### Транзакции
Логическая единица работы, которая выполняется в базе данных. Транзакции обеспечивают атомарность, согласованность, изоляцию и долговечность (ACID) операций. Это означает, что все операции внутри транзакции либо полностью выполняются, либо не выполняются вовсе, что предотвращает появление неконсистентных данных.

Основные команды для работы с транзакциями в SQL:

- BEGIN или START TRANSACTION: Начинает новую транзакцию.
- COMMIT: Подтверждает все изменения, сделанные в рамках транзакции.
- ROLLBACK: Отменяет все изменения, сделанные в рамках транзакции.

### Уровни изоляции транзакций в MySQL
Уровень изоляции транзакции определяет, какие изменения, сделанные другими транзакциями, видны текущей транзакции. MySQL поддерживает четыре уровня изоляции:

- READ UNCOMMITTED: Наименьший уровень изоляции, позволяющий видеть изменения, сделанные другими транзакциями, даже если они еще не подтверждены. Это может привести к проблемам с "грязными" чтениями и фантомными чтениями.
- READ COMMITTED: Позволяет видеть только изменения, которые были подтверждены другими транзакциями. Это предотвращает "грязные" чтения, но может привести к фантомным чтениям.
- REPEATABLE READ: Позволяет видеть только изменения, которые были подтверждены до начала текущей транзакции. Это предотвращает как "грязные", так и фантомные чтения, но может привести к проблемам с блокировками.
- SERIALIZABLE: Самый высокий уровень изоляции, который гарантирует, что транзакции выполняются последовательно, как если бы они выполнялись одна за другой. Это предотвращает все проблемы с чтением, но может существенно снизить производительность из-за большего количества блокировок.

### Блокировка и разблокировка таблиц
Блокировка и разблокировка таблиц используются для управления доступом к данным в многопользовательской среде. Блокировка предотвращает одновременное изменение данных разными транзакциями, что может привести к конфликтам и неконсистентности.

- Блокировка: MySQL автоматически блокирует таблицы на чтение или запись при выполнении операций, которые могут изменить данные. Это предотвращает одновременное изменение данных разными транзакциями.
- Разблокировка: После завершения операции над таблицей MySQL автоматически разблокирует таблицу, позволяя другим транзакциям получить доступ к ней.
Управление блокировками важно для обеспечения целостности данных и предотвращения конфликтов при одновременном доступе к данным разными пользователями или процессами.

## Представления (Views) в MySQL
Виртуальная таблица, основанная на результатах запроса. Представления не хранят данные сами по себе; они динамически генерируют данные из одной или нескольких таблиц при каждом обращении к ним. Представления могут быть использованы для упрощения сложных запросов, обеспечения безопасности данных и создания логических группировок данных.

### Создание представления
Для создания представления используется оператор CREATE VIEW. \
Синтаксис выглядит следующим образом:
```
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```
Пример создания представления:
```
CREATE VIEW EmployeeView AS
SELECT EmployeeID, FirstName, LastName, Department
FROM Employees
WHERE Active = 1;
```
### Использование представлений
После создания представления его можно использовать как обычную таблицу в запросах. \ 
Представления могут быть использованы в операторах SELECT, INSERT, UPDATE и DELETE, но с ограничениями:
- SELECT: Можно использовать представление в любом запросе SELECT.
- INSERT: Можно вставлять данные в представление, если оно основано на одной таблице и не содержит условий WHERE.
- UPDATE: Можно обновлять данные в представлении, если оно основано на одной таблице и не содержит условий WHERE.
- DELETE: Можно удалять данные из представления, если оно основано на одной таблице и не содержит условий WHERE.

### Удаление представления
Для удаления представления используется оператор DROP VIEW. \
Синтаксис:
```
DROP VIEW [IF EXISTS] view_name;
```
Пример удаления представления:
```
DROP VIEW IF EXISTS EmployeeView;
```
### Преимущества использования представлений
- Упрощение запросов: Представления могут упрощать сложные запросы, скрывая детали реализации.
- Безопасность данных: Представления могут ограничивать доступ к данным, позволяя пользователям видеть только те данные, которые им необходимы.
- Логическая группировка данных: Представления могут группировать данные из нескольких таблиц в одну логическую структуру.

### Ограничения использования представлений
- Не все операции доступны для представлений, особенно в отношении INSERT, UPDATE и DELETE.
- Представления не могут быть использованы в операторах ALTER TABLE.
- Представления в MySQL являются мощным инструментом для управления данными и обеспечения безопасности, позволяя разработчикам и администраторам баз данных создавать сложные логические структуры данных без необходимости изменения физической структуры базы данных.

